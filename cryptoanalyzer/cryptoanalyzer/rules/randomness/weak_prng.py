# cryptoanalyzer/rules/randomness/cwe_338_weak_prng.py

"""
Rule to detect Use of Cryptographically Weak PRNG (CWE-338).

This rule flags any use of Python’s built-in pseudo-random number generator
(`random.Random` or functions in the `random` module) in security-sensitive
contexts, because these PRNGs are deterministic and not suitable for cryptographic use.

Patterns detected include:
  1. Instantiation of `random.Random()` (without a secure seed) or any direct use of
     the `random` module’s functions (e.g., `random.random()`, `randint()`, `getrandbits()`, etc.).
  2. Variables whose names suggest security use (e.g., “key”, “nonce”, “iv”, “token”)
     being assigned from a `random` call.
  3. Any call to `random.seed(...)`, since seeding a weak PRNG does not make it secure.

By catching these patterns, we ensure cryptographic values (keys, nonces, IVs, tokens)
are not generated by a weak PRNG, fulfilling CWE-338.
"""

import ast
from typing import List

from cryptoanalyzer.rules import Rule
from cryptoanalyzer.utils.metadata import Finding
from cryptoanalyzer.utils.ast_utils import get_full_attr_name


class Cwe338WeakPrngRule(Rule):
    @property
    def name(self) -> str:
        return "CWE338WeakPRNG"

    @property
    def description(self) -> str:
        return (
            "Use of a cryptographically weak PRNG (`random` module or `random.Random`) "
            "for generating security-sensitive values."
        )

    @property
    def cwe_ids(self) -> List[str]:
        return ["CWE-338"]

    # List of non-crypto random functions in the `random` module
    _random_functions = {
        "random", "randint", "randrange", "getrandbits", "randbytes",
        "choice", "choices", "shuffle", "uniform", "triangular",
        "betavariate", "expovariate", "gauss", "lognormvariate",
        "normalvariate", "vonmisesvariate", "paretovariate", "weibullvariate",
        "sample"
    }

    # Variable name fragments that imply security use
    _sensitive_fragments = {"key", "nonce", "iv", "token", "salt"}

    def check(self, tree: ast.AST, file_path: str) -> List[Finding]:
        findings: List[Finding] = []

        # Attach parent pointers so assignment checks can inspect variable names
        for node in ast.walk(tree):
            for child in ast.iter_child_nodes(node):
                setattr(child, "parent", node)

        for node in ast.walk(tree):
            # Only inspect call expressions
            if not isinstance(node, ast.Call):
                continue

            func = node.func

            # --- 1) Calls to random.* functions ---
            if isinstance(func, ast.Attribute):
                full = get_full_attr_name(func).lower()
                if full.startswith("random."):
                    # e.g., random.random(), random.randint(), etc.
                    func_name = full.split(".", 1)[1]
                    if func_name in self._random_functions or func_name == "seed":
                        findings.append(self._make_finding(node, file_path))
                        continue

                # --- 2) Instantiation of random.Random() ---
                if full == "random.random":
                    # Covers both `import random; random.Random()` and `from random import Random; Random()`
                    findings.append(self._make_finding(node, file_path))
                    continue

            # --- 2b) Direct call if Random was imported directly: Random() ---
            if isinstance(func, ast.Name) and func.id == "Random":
                findings.append(self._make_finding(node, file_path))
                continue

            # --- 3) Assignment of security-sensitive variable from random call ---
            parent = getattr(node, "parent", None)
            if isinstance(parent, ast.Assign) and len(parent.targets) == 1:
                target = parent.targets[0]
                if isinstance(target, ast.Name):
                    var_name = target.id.lower()
                    if any(fragment in var_name for fragment in self._sensitive_fragments):
                        # Check if this call is to a random function
                        if isinstance(func, ast.Attribute):
                            full = get_full_attr_name(func).lower()
                            if full.startswith("random.") and (
                                full.split(".", 1)[1] in self._random_functions
                                or full.split(".", 1)[1] == "randbytes"
                            ):
                                findings.append(self._make_finding(node, file_path))
                                continue
                        if isinstance(func, ast.Name) and func.id.lower() in self._random_functions:
                            findings.append(self._make_finding(node, file_path))
                            continue

        return findings

    def _make_finding(self, node: ast.AST, file_path: str) -> Finding:
        return Finding(
            file_path=file_path,
            line=getattr(node, "lineno", 0),
            col=getattr(node, "col_offset", 0),
            rule=self.name,
            message=self.description,
            cwe_ids=self.cwe_ids,
        )
